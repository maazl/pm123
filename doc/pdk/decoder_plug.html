<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=windows-1252">
    <title>Decoder Plugins</title>
    <link rel="stylesheet" href="../common/infstyle.css" type="text/css">
  </head>
  <body>
    <h1>PM123 Decoder Plugins</h1>
    <p>Decoder plugins must implement and export the functions defined in <tt>decoder_plug.h</tt>.</p>
    <p>There are two interface revision levels. For developing new plugins the <strong><a href="#level_3">level 3 interface</a> is
        strongly recommended</strong>. But <a href="decoder_plug_1.html">level 0/1 plugins</a> are still supported. The level 2 of
      PM123 1.40 is discontinued.</p>
    <p>Decoder plugins are used to <em>decode audio data</em> as well as to <em>examine playlists</em>. Each item is identified by
      an URI.<br>
      You should not take the term 'playlist' too literally. It only means that an URI has logically a sequence of sub URIs, i.e.
      the URI has to be enumerable. This applies to a playlist as well as to a file system folder or&nbsp;a compact disc containing
      tracks.<br>
      In theory an item could be enumerable as well as directly playable. E.g. index tracks of a CD or a CUE sheet. But this has not
      been well tested in the PM123 core so far. </p>
    <h2><a name="level_3"></a>Interface revision level 3 (recommended)</h2>
    <p>The level 3 interface has the following components:</p>
    <ol>
      <li><a href="#playback_interface">Playback interface</a>, <a href="#status_interface">status interface</a> and <a href="#output_interface">output
          interface</a><br>
        This interfaces are used to play audio data. <em>Plugins that only support playlists do not need to export these
          interfaces.</em></li>
      <li><a href="#info_interface">Info interface</a>, <a href="#save_interface">save interface</a><br>
        This interface is used to obtain or change information of a song or a playlist and to identify whether an item is supported
        by the plugin.</li>
      <li><a href="#GUI_interface">GUI enhancement interface</a></li>
    </ol>
    <h3><a name="info_interface"></a>Info interface</h3>
    <p>The info interface functions must be independent of the current decoder status. They should always be functional and give
      consistent results in any conditions. The functions must be <em>thread safe</em>.</p>
    <h4><a name="decoder_support"></a>decoder_support</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_support</b>(const <a href="decoder_plug.html#DECODER_FILETYPE">DECODER_FILETYPE</a>** <var>types</var>, int* <var>count</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>types</var></code>&nbsp;(out) - Pointer to the first element of an array of supported file types.</li>
      <li><var><code>count</code></var>&nbsp;(out) - Number of entries in the above array.</li>
      <li><var>return value</var> - return what kind of stream can the decoder play:<br>
        <tt> DECODER_FILENAME</tt> (1) - Decoder can play files (including UNC names).<br>
        <tt> DECODER_URL</tt> (2) - Decoder can play internet URIs (http, ftp, etc.).<br>
        <tt> DECODER_TRACK</tt> (4) - Decoder can play CD tracks, i.e. cdda URIs.<br>
        <tt> DECODER_OTHER</tt> (8) - Decoder can play something else.<br>
        <tt>DECODER_SONG</tt> (0x0100) - Decoder can play songs.<br>
        <tt>DECODER_PLAYLIST</tt> (0x0200) - Decoder can read playlists.<br>
        <tt>DECODER_WRITABLE</tt> (0x1000) - Decoder can save items.<br>
        <tt>DECODER_METAINFO</tt> (0x2000) - Decoder can save meta info.<br>
        The values should be ored as required.</li>
    </ul>
    <p>This is used by PM123 to suggest to the user what he can play with the decoder. Furthermore, by default <em>PM123 will not
        query the decoder about files or other objects that are not listed in the above filter list</em> to keep performance up. </p>
    <p>The function is called again after a successful call to <a href="index.html#plugin_configure"><tt>plugin_configure</tt></a>.
      This allows to modify the supported file types through the configuration.</p>
    <h4><a name="decoder_fileinfo"></a>decoder_fileinfo</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_fileinfo</b>(const char *<var>url</var>, XFILE* <var>handle</var>, int* <var>what</var>, const <a
href="datatype.html#INFO_BUNDLE">INFO_BUNDLE</a>* <var>info</var>,<br>                              &nbsp; <a href="decoder_plug.html#DECODER_INFO_ENUMERATION_CB">DECODER_INFO_ENUMERATION_CB</a> <var>cb</var>, void* <var>param</var>)</pre>
    </blockquote>
    <ul>
      <li><tt><var>url</var></tt> - URL to the desired stream. See <a href="decoder_plug.html#url_samples">URL samples</a>.</li>
      <li><var><tt>handle</tt></var> - optional XIO object handle. If the core engine can open the object via XIO then it passes the
        handle to the decoder to avoid that every decoder opens the object anew only to find out that it does not support it. The
        handle is opened in binary read only mode with deny none and with synchronous buffering enabled. Even if the source stream
        does not support seeking, you may seek within one buffer size. The buffer size depends on the protocol. It it at least 4kiB,
        so you should not read more than the first 4kiB.<br>
        Decoders should use this handle unless they have a good reason not to do so. <em>Decoders must not close the handle</em>.
        Only decoders that returned <tt>DECODER_OTHER</tt> at <tt>decoder_support</tt> may be called with <tt><var>handle</var>
          == NULL</tt>.</li>
      <li><tt><var>what</var></tt> (in/out) - Bit vector of <a href="datatype.html#INFOTYPE"><tt>INFOTYPE</tt></a>. The requested
        fields in <a href="datatype.html#INFO_BUNDLE"><tt>INFO_BUNDLE</tt></a>.<br>
        The decoder may return more information than requested if it is cheap to do so. In this case it should set the additional
        bits in <tt>*<var>what</var></tt> to notify PM123 that the desired information is valid too.<br>
        The decoder <em>must not return less information</em> than requested. However, some information may not have any content
        for the desired object. In this case there is no need to modify the appropriate fields in <tt>*<var>info</var></tt>.<br>
        If <tt>*<var>what</var></tt> is <tt>0</tt> on input, the information in <tt>INFO_BUNDLE</tt> is not required at all. Only
        the return value of <tt>decoder_fileinfo</tt> is used. However, the decoder may return more even in this case.</li>
      <li><tt><var>info</var></tt> (out) - this structure must be filled at least with the information required by <tt>*<var>what</var></tt>.&nbsp;See
        <tt><a href="datatype.html#INFO_BUNDLE"><tt>INFO_BUNDLE</tt></a></tt> for further details. All entries of <tt>INFO_BUNDLE</tt>
        point to the appropriate structures when <tt>decoder_fileinfo</tt> is called.<br>
        If some information is not available, the requested fields in <tt>INFO_BUNDLE</tt> should be left unchanged. Normally all
        fields have their initial value. But the <tt>TECH_INFO</tt> sub structure could contain some format information from a
        playlist plugin or an earlier call. This could be used to read raw PCM files.<br>
        If the handle parameter is not NULL, the PHYS_INFO structure is already filled with the appropriate values.<br>
        Note, that leaving fields initial is different from unrequested informations where the corresponding bits in <tt>*<var>what</var></tt>
        are not set. In the latter case the information <em>might</em> become available later on request. It is just not yet known.<br>
        In case of an error (non-zero return value) the decoder should return an error text in the <tt>tech-&gt;info</tt> field, if
        available.</li>
      <li><code><var>cb</var></code> - Callback function.<br>
        If <tt>INFO_OTHER</tt> is requested, the decoder has to call this function once for each item in the playlist (or
        collection) before <code>decoder_fileinfo</code> returns. Of course, this does not apply to songs.</li>
      <li><code><var>param</var></code> - This parameter is to be passed as first argument to each call to <code>*<var>cb</var></code>.</li>
      <li><var>return value</var> -<br>
        <tt> PLUGIN_OK</tt> (<tt>0</tt>) = everything's perfect, structure is set.<br>
        <tt> PLUGIN_NO_READ</tt> (<tt>100</tt>) = error reading file. <em>This error should only be set if there is no chance that
          any other plugin may read this URL.</em> E.g. if it is a file URI and the file does not exist or if it is a http URI and
        the domain does not exist or the server does not respond on the port. In fact decoders normally shall not return <tt>
          PLUGIN_NO_READ</tt> if they are called with a valid <var><tt>handle</tt></var>.<br>
        <tt> PLUGIN_NO_PLAY</tt> (<tt>200</tt>) = this decoder can't play that. PM123 will try other decoders if available.</li>
    </ul>
    <table cellspacing="0" cellpadding="3" border="1">
      <tbody>
        <tr>
          <th>bit in <tt>*<var>what</var></tt> on input</th>
          <th>bit in <tt>*<var>what</var></tt> on return</th>
          <th>corresponding info available</th>
          <th>corresponding fields in&nbsp;<tt>INFO_BUNDLE</tt></th>
        </tr>
        <tr>
          <td align="center">reset</td>
          <td align="center">reset</td>
          <td align="center">don't care</td>
          <td>ignored</td>
        </tr>
        <tr>
          <td align="center">set</td>
          <td align="center">reset</td>
          <td align="center">don't care</td>
          <td><strong>not allowed!</strong></td>
        </tr>
        <tr>
          <td align="center">don't care</td>
          <td align="center">set</td>
          <td align="center">no</td>
          <td>leave unmodified</td>
        </tr>
        <tr>
          <td align="center">don't care</td>
          <td align="center">set</td>
          <td align="center">yes</td>
          <td>fill with valid content</td>
        </tr>
      </tbody>
    </table>
    <p>If a decoder knows that some information, that is not explicitly requested, is not available for the current URI or it knows
      it's content during processing of the request, it should always set the corresponding bit in <tt>*<var>what</var></tt> and
      return the information if applicable. This avoids redundant calls to <tt>decoder_fileinfo</tt>.</p>
    <p>PM123 does not need all informations for all kind of objects. <em>The aggregate type recursive playlist information is never
        requested explicitly by PM123.</em> PM123 will also never request <tt>INFO_PHYS</tt> if a <var><tt>handle</tt></var> is
      not <tt>NULL</tt>. However, a plugin may supply aggregate information if it is available. E.g. playlists may store cached
      information about their children to improve performance. If you are in doubt, do not supply this kind of information.</p>
    <p style="float: right;"><u>Legend:</u><br>
      <strong>X</strong> = required if requested by the PM123<br>
      Q = may be requested by the PM123<br>
      <em>C</em>&nbsp;= my be cached and returned by the decoder<br>
      O = may be overridden by a playlist item </p>
    <table cellspacing="0" cellpadding="3" border="1">
      <tbody>
        <tr>
          <th>info type</th>
          <th>song</th>
          <th>playlist</th>
          <th>playlist item</th>
        </tr>
        <tr>
          <td><code>phys</code></td>
          <td align="center"><strong>X</strong> </td>
          <td align="center"><strong>X</strong> </td>
          <td align="center"><em></em><em>C</em></td>
        </tr>
        <tr>
          <td><code>tech</code></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><em>C</em></td>
        </tr>
        <tr>
          <td><code>obj</code></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><em>C</em></td>
        </tr>
        <tr>
          <td><code>meta</code></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><em>C</em> O</td>
        </tr>
        <tr>
          <td><code>attr</code></td>
          <td align="center">Q</td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><em>C</em> O</td>
        </tr>
        <tr>
          <td>children</td>
          <td align="center">Q</td>
          <td align="center"><strong>X</strong></td>
          <td> <br>
          </td>
        </tr>
        <tr>
          <td><code>rpl</code></td>
          <td>&nbsp;</td>
          <td align="center"><em>C</em><em></em></td>
          <td align="center"><em>C</em></td>
        </tr>
        <tr>
          <td><tt>drpl</tt></td>
          <td>&nbsp;</td>
          <td align="center"><em>C</em><em></em></td>
          <td align="center"><em>C</em></td>
        </tr>
        <tr>
          <td><tt>item</tt></td>
          <td> <br>
          </td>
          <td> <br>
          </td>
          <td align="center">O</td>
        </tr>
      </tbody>
    </table>
    <br>
    <h5><a name="DECODER_INFO_ENUMERATION_CB"></a>DECODER_INFO_ENUMERATION_CB</h5>
    <blockquote>
      <pre>void (DLLENTRY* <b>cb</b>)(void* <var>param</var>, const char* <var>url</var>, const <a href="datatype.html#INFO_BUNDLE">INFO_BUNDLE</a>* <var>info</var>,&nbsp;int <var>cached</var>, int <var>reliable</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>param</var></code> - Arbitrary parameter from&nbsp;<code>decoder_fileinfo</code>.</li>
      <li><code><var>url</var></code> - URI of the sub item. The URI may be absolute or relative. In case of relative URIs the
        context of the enclosing playlist is used for URI resolution.</li>
      <li><code><var>info</var></code> - Known information about the sub item. If you already know some information about an item,
        you should place it in <code>*<var>info</var></code>. This can make PM123 significantly faster. If you do not have any
        information, you can pass <code>NULL</code> as <code><var>info</var></code>.</li>
      <li><code><var>cached, reliable</var></code> - Two bit vectors of <tt><a href="datatype.html#INFOTYPE"><tt>INFOTYPE</tt></a></tt>
        corresponding to fields in <tt>*<var>info</var></tt>.<br>
        <table cellspacing="0" cellpadding="3" border="1">
          <tbody>
            <tr>
              <th><var><tt>cached</tt></var></th>
              <th><var><tt>reliable</tt></var></th>
              <th>Corresponding field in <tt>*<var>info</var></tt> contains</th>
            </tr>
            <tr>
              <td valign="top" align="center">0</td>
              <td valign="top" align="center">0</td>
              <td valign="top">- ignored -, may be <tt>NULL</tt></td>
            </tr>
            <tr>
              <td valign="top" align="center">1</td>
              <td valign="top" align="center">0</td>
              <td valign="top">The field contain <i>cached</i> information that might no longer be valid.</td>
            </tr>
            <tr>
              <td valign="top" align="center">0</td>
              <td valign="top" align="center">1</td>
              <td valign="top">The field contains <i>reliable</i> information that just had been verified.</td>
            </tr>
            <tr>
              <td valign="top" align="center">1</td>
              <td valign="top" align="center">1</td>
              <td valign="top">The field contains information that is <i>overridden
                  by
                  this reference</i> only.</td>
            </tr>
          </tbody>
        </table>
        You may use overridden information e.g. to give meaningful meta information to a slice of an object. For example a cue sheet
        may reference slices of a long file, but the slices have different meta information although the underlying object is the
        same. You cannot override all kind of information. See the above matrix for details.</li>
    </ul>
    <h3><a name="playback_interface"></a>Playback interface</h3>
    <h4>decoder_init, decoder_uninit</h4>
    <blockquote>
      <pre>int DLLENTRY <b>decoder_init</b> (struct DECODER_STRUCT **<var>w</var>)</pre>
    </blockquote>
    <ul>
      <li><tt><var>w</var></tt> - Allocate any chunk of memory necessary for the decoder's function. This pointer will be passed to
        the other functions. The type <tt>struct DECODER_STRUCT</tt> is incomplete. You may fill it with life or simply cast to
        your own type.</li>
      <li>return value:<br>
        <tt>PLUGIN_OK</tt> (<tt>0</tt>) means success.<br>
        <tt>PLUGIN_FAILED</tt> (<tt>-1</tt>) means the decoder was not initialized successfully.</li>
    </ul>
    The <tt>decoder_init</tt> function is called when PM123 needs the specified decoder to play the stream demanded by the user. So
    only one decoder plugin is active at any given time. It should initialize the necessary semaphores and threads.
    <blockquote>
      <pre>BOOL DLLENTRY <b>decoder_uninit</b>(struct DECODER_STRUCT *<var>w</var>)</pre>
    </blockquote>
    <ul>
      <li><tt><var>w</var></tt> - The pointer received by <tt>decoder_init</tt>. </li>
      <li>return value: <tt>TRUE</tt> = success</li>
    </ul>
    <p><code>decoder_uninit</code> is called when another decoder than yours is needed, and should destroy the decoder's thread,
      semaphores, other opened handles and free allocated memory for <tt><var>w</var></tt>. The decoder must not execute any
      callback function like <a href="#OutRequestBuffer"><tt>OutRequestBuffer</tt></a> from another thread when <tt>decoder_uninit</tt>
      has returned.</p>
    <h4><a name="decoder_command"></a>decoder_command</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_command</b>(struct DECODER_STRUCT *<var>w</var>, ULONG <var>msg</var>, DECODER_PARAMS2 *<var>params</var>)</pre>
    </blockquote>
    <ul>
      <li><tt><var>msg</var></tt> - one of the following:
        <ul>
          <li><tt>DECODER_SETUP</tt> - setup various parameters such as the output plugin functions.</li>
          <li><tt>DECODER_PLAY</tt> - start playing the given filename, URL or others.</li>
          <li><tt>DECODER_FFWD</tt> - engage in ffwd mode (i.e.: play faster or skip forward or backward when playing).</li>
          <li><tt>DECODER_JUMPTO</tt> - jump and start decoding at the given time position.</li>
          <li><tt>DECODER_SAVEDATA</tt> - tells the decoder to start saving the stream to HD.</li>
          <li><tt>DECODER_STOP</tt> - stop playing.</li>
        </ul>
      </li>
      <li><tt><var>params</var></tt> - structure that contains the parameters needed by the preceding commands.</li>
      <li>return value:<br>
        <tt>PLUGIN_OK</tt> (<tt>0</tt>) -&gt; ok.<tt> <br>
          PLUGIN_UNSUPPORTED (</tt><tt>1) -&gt; command u</tt>nsupported.<br>
        <tt>DECODER_PLAY</tt> and <tt>DECODER_STOP</tt> can return also <tt>PLUGIN_GO_ALREADY</tt> (<tt>101</tt>) and <tt>PLUGIN_GO_FAILED</tt>
        (<tt>102</tt>).</li>
    </ul>
    <p>There are a lot of commands to implement for this function. Parameters needed for each of them are passed in the <a href="decoder_command.html#DECODER_PARAMS2"><tt>DECODER_PARAMS2</tt></a>
      structure and described in detail <a href="decoder_command.html">here</a> and in the <tt>decoder_plug.h</tt> include. The
      decoder necessarily should support following commands: <tt>DECODER_SETUP</tt>, <tt>DECODER_PLAY</tt> and <tt>DECODER_STOP</tt>.</p>
    <p><a name="url_samples"></a>In the level 3 interface the data source always passed as an URL. The URL parameter uses the
      following syntax:</p>
    <blockquote><samp>file:///D:/Music/my favorite song.mp3</samp><br>
      <samp>file://server/share/path/song.mp3 </samp>(UNC path)<br>
      <samp>http://... </samp>(as you would expect)<br>
      <samp>cdda:///H:/track02</samp> (CD track)<br>
      <samp>cdda:///H:/</samp> (CD TOC) </blockquote>
    <h5><tt>DECODER_SETUP</tt></h5>
    <blockquote>The <tt><tt>DECODER_SETUP</tt></tt> call is intended to capture the callback entries for the <a href="#output_interface">output
        interface</a>. They do not change during decoding.</blockquote>
    <h5><tt>DECODER_PLAY</tt></h5>
    <blockquote>
      <p>This command tell the decoder which song to decode. This should spawn a new thread that decodes the song and feeds the
        result to the <a href="#output_interface">output interface</a>.</p>
    </blockquote>
    <h5><tt>DECODER_JUMPTO</tt></h5>
    <blockquote>
      <p>Tells the decoder to continue decoding at a certain location of the song. The structure member <tt>JumpTo</tt> is the
        location in seconds from the song's start.</p>
    </blockquote>
    <h5><tt>DECODER_FFWD</tt></h5>
    <blockquote>
      <p>Change the fast forward or rewind mode. The structure member <tt>SkipSpeed</tt> tell the decoder which playback speed is
        intended. The value i a delta to the normal playback speed, i.e. <var>speed</var> = <var><tt>SkipSpeed</tt></var> + 1.
        Examples:</p>
      <ul>
        <li><b>0.0</b> =&gt; normal playback</li>
        <li>1.0 =&gt; play twice as fast</li>
        <li><b>3.0</b> =&gt; play 4 times faster</li>
        <li>-2.0 =&gt; play reverse</li>
        <li>-3.0 =&gt; play reverse twice as fast</li>
        <li><b>-5.0</b> =&gt; play revers 4 time faster</li>
        <li>-0.5 =&gt; play at half speed (currently unused)</li>
      </ul>
      <p>There is no need to hit this value exactly. It is better to skip parts of the song instead of transforming the sample rate.
        Common values are marked bold. If a decoder can't support different speeds, it could simply use <tt>SkipSpeed</tt> &gt; 0
        for fast forward, and <tt>SkipSpeed</tt> &lt; 0 for fest rewind.</p>
      <p><u>Implementation hint:</u> If you implement fast scan mode by seeking every 100 ms forward or reverse, then you need to
        seek <tt>SkipSpeed</tt> * 100 ms every time to get the desired average speed.</p>
    </blockquote>
    <h5><tt>DECODER_STOP</tt></h5>
    <blockquote>
      <p>Stop decoding of the current song. This should terminate the decoder thread. After <tt>DECODER_STOP</tt> the decoder
        should ignore all errors and simply terminate.</p>
    </blockquote>
    <h3><a name="status_interface"></a>Status interface</h3>
    <p>The status interface has to be <em>thread safe</em>.</p>
    <h4><a name="decoder_status"></a>decoder_status</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_status</b>(struct DECODER_STRUCT *<var>w</var>)</pre>
    </blockquote>
    <ul>
      <li><i>return value</i> - One of the following:<br>
        <tt>DECODER_STOPPED<br>
          DECODER_PLAYING<br>
          DECODER_STARTING<br>
          DECODER_PAUSED<br>
          DECODER_STOPPING</tt></li>
    </ul>
    <h4><a name="decoder_length"></a>decoder_length</h4>
    <blockquote>
      <pre>PM123_TIME DLLENTRY <b>decoder_length</b>(struct DECODER_STRUCT *w)</pre>
    </blockquote>
    <ul>
      <li><i>return value</i> - number of seconds the stream lasts (you can report <code>-1</code> if unknown).</li>
    </ul>
    <p>The call to this function must be valid even if <tt>DECODER_STARTING</tt> or <tt>DECODER_STOPPED</tt> is reported (when the
      stream plays too fast for example). The function is used to follow increasing length of files that are written on the fly
      while playing.</p>
    <h3><a name="output_interface"></a>Output interface</h3>
    <p>The decoder must use this interface to pass the decoded samples to the output stage. The samples must be passed as <em>32
        bit floating point values</em>.</p>
    <p>Strictly speaking this is part of the <a href="#playback_interface">playback interface</a>, but the interface functions have
      to be called by the decoder in a separate thread.&nbsp;The function entry points for these callbacks are passed in <code>DECODER_PARAMS2</code>
      at the <tt><a href="#decoder_command">DECODER_SETUP</a></tt> call.</p>
    <p>The level 3 interface allocates the buffers by the consumer. This causes less double buffering and allows dynamic buffer
      sizes. In the optimal case the samples can be placed immediately in the output buffers of the audio device.</p>
    <p>You must call <code>OutRequestBuffer</code> and <code>OutCommitBuffer</code> alternately to pass the samples to the next
      plugin. Anything else is an error. Note that any of the two functions might block.</p>
    <h4><a name="OutRequestBuffer"></a><b>OutRequestBuffer</b></h4>
    <blockquote>
      <pre>int (DLLENTRYP <b>OutRequestBuffer</b>)(void* <var>a</var>, const <a href="datatype.html#FORMAT_INFO2">FORMAT_INFO2</a>* <var>format</var>, float** <var>buf</var>)</pre>
    </blockquote>
    <ul>
      <li><tt><var>a</var></tt> - pointer from <code>DECODER_PARAMS2</code>.</li>
      <li><tt><var>format</var></tt> - format of the passed samples. The data at <code>*<var>format</var></code> need not to be
        valid after this call returned.</li>
      <li><tt><var>buf</var></tt> [out] - pointer to receive a memory location where to store the decoded samples.</li>
      <li><var>return value</var> - the number of samples that fit in the returned buffer. A return value of &#8804;&nbsp;0 indicates a
        permanent error. PM123 stops the playback in this case.</li>
    </ul>
    <p>If you get a smaller buffer as you need to pass your data you should call <code>OutRequestBuffer</code> and <code>OutCommitBuffer</code>
      again until all your data is consumed. There is no guaranteed minimum size of the buffer, but you should not expect to get
      very small buffers quite often.</p>
    <h4><a name="OutCommitBuffer"></a><b>OutCommitBuffer</b></h4>
    <blockquote>
      <pre>void (DLLENTRY* <b>OutCommitBuffer</b>)(void* <var>a</var>, int <var>len</var>, <a href="datatype.html#PM123_TIME">PM123_TIME</a> <var>posmarker</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>a</var></code> - pointer from <code>DECODER_PARAMS2</code>.</li>
      <li><code><var>len</var></code> - used number of samples placed in the buffer.</li>
      <li><code><var>posmarker</var></code> - stream position in seconds of the first sample that will be stored in this buffer
        relative to the beginning of the stream.</li>
    </ul>
    <p>The length must not be higher than the the return value from the previous <code>OutRequestBuffer</code> call. But it might
      be less than the requested length. This causes no significant performance impact as long as you do not always pass very few
      samples.</p>
    <h4><a name="DecEvent"></a>DecEvent</h4>
    Send decoder event to the PM123 core.<br>
    <blockquote>
      <pre>void (DLLENTRY* <b>DecEvent</b>)(void* <var>a</var>, DECEVENTTYPE <var>event</var>, void* <var>param</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>a</var></code> - pointer from <code>DECODER_PARAMS2</code>.</li>
      <li><code><var>event</var></code> - type of the event to send.</li>
      <li><code><var>param</var></code> - event specific parameter. See below.</li>
    </ul>
    <p>The decoder plugin MUST call the above function on the following conditions:</p>
    <ul>
      <li><code><b>DECEVENT_PLAYSTOP</b></code> when the stream has finished decoding and the last sample has been passed to <code>output_commit_buffer</code>
        or when the decoder received a <tt>DECODER_STOP</tt> command.</li>
      <li><code><b>DECEVENT_PLAYERROR</b></code> when a playback error occurred so that PM123 should know to stop immediately.<br>
        <var><tt>param</tt></var> could optionally point to an error text or should be NULL otherwise. Passing a buffer to a
        temporary storage is valid. The information is copied by the PM123 core before the function returns.</li>
      <li><code><b>DECEVENT_SEEKSTOP</b></code> when a <code>DECODER_JUMPTO</code> operation is completed (i.e. when no buffers
        from before the seek is sent to the output plugin anymore). The message must also be sent, when playback starts in the
        middle of a song. </li>
      <li><code><b>DECEVENT_CHANGETECH</b></code> is sent whenever you want PM123 to change the display of the current technical
        information of the stream (like samplerate). <var>param</var> must point to a <code>TECH_INFO</code> structure.</li>
      <li><code><b>DECEVENT_CHANGEOBJ</b></code> is sent whenever you want PM123 to change the display of the current object
        information of the stream (like song length). <var>param</var> must point to a <code>OBJ_INFO</code> structure. Note that
        you should not sent the bitrate of individual MPEG frames this way like the level 1 interface supported by <tt>WM_CHANGEBR</tt>.
        The object information keeps the bitrate of the entire stream. </li>
      <li><code><b>DECEVENT_METADATA</b></code> is sent whenever streaming metadata is updated. <var>param</var> must point to a <code>META_INFO</code>
        structure.</li>
    </ul>
    Once a decoder raised a <tt>DECODER_PLAYSTOP</tt> or <tt>DECODER_ERROR</tt> event it shall not use any callback functions
    until it receives a <tt>DECODER_PLAY</tt> command.<br>
    <h4><a name="decoder_event"></a>decoder_event</h4>
    Receive event from the PM123 core.<br>
    <blockquote>
      <pre>void DLLENTRY <b>decoder_event</b>(void* <var>w</var>, OUTEVENTTYPE <var>event</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>w</var></code> - pointer from <code>decoder_init</code></li>
      <li> <var>event</var> - one of the following values<br>
        <code>OUTEVENT_LOW_WATER</code> - the output plugin detected that it will run out of data soon.<br>
        <code>OUTEVENT_HIGH_WATER</code> - the output plugin detected a clear condition.</li>
    </ul>
    <p>The events may be used to speed up the data source. If you get <code>OUTEVENT_HIGH_WATER</code> you should return to normal
      behavior. There is one task that the core engine does for you: <em>PM123 automatically changes the priority of the decoder
        thread</em>. So if there is nothing more the decoder can do (e.g. QoS settings) it could safely ignore the events. </p>
    <p>The event handler may be called from any thread in any context. It might be called when the decoder is in stopped state if
      the end of the stream has been reached recently. This should be ignored. You will usually get a <code>OUTEVENT_LOW_WATER</code>
      call immediately after the decoding started or after a seek command because the buffers are not yet filled.</p>
    <p>The export of <tt>decoder_event</tt> is optional.</p>
    <var></var>
    <h3><a name="save_interface"></a>Save interface</h3>
    <h4><a name="decoder_saveinfo"></a>decoder_saveinfo</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_saveinfo</b>(char* <var>url</var>, const META_INFO* <var>info</var>, int <var>haveinfo</var>, xstring* <var>errortext</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>url</var></code> - URI to the desired object.</li>
      <li><code><var>info</var></code> - new meta information to write.<br>
        Only the fields with the corresponding bits in <tt><var>haveinfo</var></tt> set must be modified. The others should be left
        unchanged. </li>
      <li><code><var>haveinfo</var></code> - Components of info to modify.</li>
      <li><var><tt>errortext</tt></var> - place a descriptive error text here if the function fails.<var> </var></li>
      <li><var>return value</var><br>
        <code>PLUGIN_OK</code> (0) = everything is perfect, meta info is saved to <code><var>url</var></code>.<br>
        <tt>PLIGIN_ERROR</tt> (<tt>500</tt>) = failed.</li>
    </ul>
    <p>The function modifies the meta information of a certain song. Calling the function should succeed even if the file is
      currently playing.</p>
    <h4><a name="decoder_savefile"></a>decoder_savefile</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_savefile</b>(const char* <var>url</var>, const char* format, int* <var>what</var>, const INFO_BUNDLE* <var>info</var>,<br>                                <a
href="#DECODER_SAVE_ENUMERATION_CB">DECODER_SAVE_ENUMERATION_CB</a> <var>cb</var>, void* <var>param</var><var></var>, xstring* <var>errortext</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>url</var></code> - URI to the desired object.<br>
        It is valid to pass a URI of a currently playing song. The decoder should be able to handle that appropriately.</li>
      <li><var><tt>format</tt></var> - optional format parameter if the decoder supports different file formats.<br>
        <code><var></var></code></li>
      <li><code><var>what</var></code> (in/out) - Bit vector of <tt><a href="datatype.html#INFOTYPE"><tt>INFOTYPE</tt></a></tt>
        flags with the information to save. Any information that corresponds to bits that are not set in <tt>*<var>what</var></tt>
        should be preserved by this call. And if <tt>INFO_META</tt> is specified, any meta information that does not have the
        corresponding bit in <tt>info-&gt;meta-&gt;haveinfo</tt> set, should be left unchanged too.<br>
        On return the decoder resets the the bits in <tt>*<var>what</var></tt> that could not be saved because they are not
        supported in the requested format.<br>
        Furthermore the decoder may set the <tt>INFO_PHYS</tt> bit to indicate that <tt>*<var>info</var>-&gt;phys</tt> has been
        updated with recent informations after the update. (Of course, PM123 will never request this on input.) </li>
      <li><var><code>info</code></var> - Information of the playlist object itself. Usually playlists do not contain additional
        object information other than their content. So the info may be mostly ignored. However, it could speed up PM123 if <code>decoder_fileinfo</code>
        can restore some infos in a cheap way.</li>
      <li><var><code>cb</code></var> - Enumeration callback. The decoder should call this function<code></code> to retrieve the
        information about the playlist content from PM123, but only if <tt>*<var>what</var></tt> contains <tt>INFO_CHILD</tt>.</li>
      <li><var><code>param</code></var> - Parameter to be passed as first argument to <code>*cb</code>.</li>
      <li><var><tt>errortext</tt></var> - place a descriptive error text here if the function fails.<var> </var></li>
      <li><var>return value</var><br>
        <code>PLUGIN_OK</code> (<tt>0</tt>) = everything is perfect, meta info is saved to <code><var>url</var></code>.<br>
        <tt>PLIGIN_ERROR</tt> (<tt>500</tt>) = failed. </li>
    </ul>
    <p>The function is used to modify a file (or other object) in place. It is currently only used to save playlists.</p>
    <h5><a name="DECODER_SAVE_ENUMERATION_CB"></a>DECODER_SAVE_ENUMERATION_CB</h5>
    <blockquote>
      <pre>int (DLLENTRY* <b>cb</b>)(void* <var>param</var>, <a href="xstring.html">xstring</a>* <var>url</var>, const <a href="datatype.html#INFO_BUNDLE">INFO_BUNDLE</a>** <var>info</var>, int* <var>cached</var>, int* <var>reliable</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>param</var></code> - Arbitrary parameter from&nbsp;<code>decoder_savelist</code>.</li>
      <li><code><var>url</var></code>&nbsp;(out) - Return URI of the sub item. The URI may be absolute or relative. In case of
        relative URIs the context of the enclosing playlist is used for URI resolution. <em>Note that the <a href="xstring.html"><tt>xstring</tt>
            structure</a> must be initialized</em> when the function is called.</li>
      <li><code><var>info</var></code> (out) - Return known information about the sub item. The decoder can store this information
        in the playlist and return it when the list is read with <a href="#decoder_fileinfo"><tt>decoder_fileinfo</tt></a> to speed
        up large playlists.<br>
        The storage where <tt>*info</tt> points to is only valid until the next call to <tt>cb</tt> or until <tt>decoder_savefile</tt>
        returned. </li>
      <li><code><var>cached, reliable</var></code> (out) - Return <a href="datatype.html#INFOTYPE"><code>INFOTYPE</code></a> bit
        vectors. See <a href="#DECODER_INFO_ENUMERATION_CB"><tt>DECODER_INFO_ENUMERATION_CB</tt></a> for details.<br>
        The decoder should not store information that is not at least cached. When both bits are set the specified type of
        information in <code>**<var>info</var></code> is overridden by this reference only. The decoder should store this
        information together with the URI reference when possible.</li>
      <li><var>return value</var> -&nbsp;<code>PLUGIN_OK</code> (<tt>0</tt>) = everything is fine, anything else = error, e.g. no
        more items.</li>
    </ul>
    This function retrieves the next sub item from the currently saved playlist. PM123 will fill all fields according to the above
    rules.
    <h5><a name="DECODER_FILETYPE"></a>DECODER_FILETYPE</h5>
    <blockquote>
      <pre>typedef struct<br>{ const char* category;<br>  const char* eatype;<br>  const char* extension;<br>  int         flags;<br>} <b>DECODER_FILETYPE</b>;</pre>
    </blockquote>
    <table cellspacing="0" cellpadding="3" border="1">
      <tbody>
        <tr>
          <th>Field</th>
          <th>Meaning</th>
        </tr>
        <tr>
          <td><tt>category</tt></td>
          <td>File type category, e.g. "<tt>Playlist file</tt>"<br>
            This field is only used for reading files.</td>
        </tr>
        <tr>
          <td><tt>eatype</tt></td>
          <td>File type, e.g. "<tt>PM123 playlist file</tt>"</td>
        </tr>
        <tr>
          <td><tt>extension</tt></td>
          <td>File extension, e.g. "<tt>*.lst;*.m3u</tt>"</td>
        </tr>
        <tr>
          <td><tt>flags</tt></td>
          <td>Bit vector of <tt>DECODER_TYPE</tt>.<br>
            <tt> DECODER_FILENAME</tt> (1) - Decoder can play files of this type, should always be set for EA types.<br>
            <tt> DECODER_URL</tt> (2) - Decoder can play URIs (http, ftp, etc.), should be set for MIME types.<br>
            <tt>DECODER_SONG</tt> (0x0100) - Decoder can play songs with this file type.<br>
            <tt>DECODER_PLAYLIST</tt> (0x0200) - Decoder can play playlists with this file type.<br>
            <tt>DECODER_WRITABLE</tt> (0x1000) - Decoder can save items of this type.<br>
            <tt>DECODER_METAINFO</tt> (0x2000) - Decoder can save a meta info. </td>
        </tr>
      </tbody>
    </table>
    <p><strong>TODO</strong></p>
    <h3><a name="GUI_interface"></a>GUI enhancement interface</h3>
    <p>The following functions are used to improve the GUI of PM123 with plugin specific content.<br>
      <em>All functions in this section are optional.</em></p>
    <h4><a name="decoder_editmeta"></a>decoder_editmeta</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_editmeta</b>(HWND <var>owner</var>, const char* <var>url</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>owner</var></code> - Parent window handle.</li>
      <li><code><var>url</var></code> - URL to the desired stream. See <a href="#url_samples">URI samples</a>. Keep in mind that
        this URL may be the same as the one currently played. The plugin must handle this concurrent write access.</li>
      <li><var>return value</var> -<br>
        <tt>PLUGIN_OK &nbsp; &nbsp;&nbsp;</tt> (<tt>0</tt>) = everything is perfect, information has been changed. PM123 will
        invalidate the Meta information of this URL and likely call <a href="#decoder_fileinfo"><tt>decoder_fileinfo</tt></a> to
        update its internal cache.<br>
        <tt>PLUGIN_NO_READ</tt> (<tt>200</tt>) = decoder can't handle that. (PM123 raises an error dialog)<br>
        <tt>PLUGIN_NO_OP &nbsp;</tt> (<tt>300</tt>) = no change, e.g. user abort. This return value should also be used when the
        plugin already raised a meaningful message using <tt>plugin_api-&gt;error_display</tt>.<br>
        <tt>PLUGIN_NO_SAVE</tt> (<tt>400</tt>) = can't edit tag of this stream. (PM123 raises an error dialog)<br>
        <tt>PLUGIN_ERROR &nbsp;</tt> (<tt>500</tt>) = error writing tag. (PM123 raises an error dialog) </li>
    </ul>
    <p>If <code>decoder_editmeta</code> is not implemented, the edit tag entry is always disabled. </p>
    <h4><a name="decoder_getwizard"></a>decoder_getwizard</h4>
    <blockquote>
      <pre>const DECODER_WIZARD* DLLENTRY <b>decoder_getwizard</b>(void)</pre>
    </blockquote>
    <ul>
      <li><var>return value</var> - Zero or more <code>DECODER_WIZARD</code> structures (linked list).<br>
        Each structure represents an entry in the context menu to load something into the player or a playlist. To terminate the
        list of <code>DECODER_WIZARD</code> objects set the link pointer to <code>NULL</code>. The returned storage must be valid
        until the next call to <code>decoder_getwizard</code> or the plugin gets unloaded.</li>
    </ul>
    <p>If the function is not implemented or returns <code>NULL</code> the context menu is not extended with entries specific to
      this plugin.</p>
    <p>The field <code>prompt</code> is the menu text. It should not contain information about the accelerator key, because this is
      generated automatically.</p>
    <p>The fields <code>accel_key</code>[<code>2</code>] and <code>accel_opt</code>[<code>2</code>] can be used to extend the
      accelerator table of PM123. They correspond to the fields <code>key</code> and <code>fs</code> of the <code>ACCEL</code>
      structure. The first set of entries is used for the PM123 main window and the playlist windows. The second set is for the
      Playlist Manager to append to the currently selected playlist.<br>
      You should set <code>accel_key</code> to <code>0</code> if you do not want an accelerator key for your plugin's wizard
      dialog. Be careful with the choice of the accelerator keys because there may be clashes. Using Alt for the first entry and
      Shift-Alt for the second entry as meta keys is recommended.</p>
    <p>When the menu entry is selected the corresponding wizard function is called by PM123.</p>
    <blockquote>
      <pre>ULONG (DLLENTRY* <b>wizard</b>)(HWND <var>owner</var>, const char* <var>title</var>,<br>                         <a href="#DECODER_INFO_ENUMERATION_CB">DECODER_INFO_ENUMERATION_CB</a> <var>callback</var>, void* <var>param</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>owner</var></code> - Parent window handle.</li>
      <li><code><var>title</var></code> - Window title.<br>
        The title may contain <samp>"%s"</samp> for the object type. E.g. <samp>"Add%s to playlist."</samp> may evaluate to <samp>"Add
          track(s) to playlist."</samp>.</li>
      <li><code><var>callback</var></code> - Function that will be called for each selected item.</li>
      <li><code><var>param</var></code> - Parameter to pass to the callback function as the first argument.</li>
      <li><var>return value</var> -<br>
        <tt>PLUGIN_OK &nbsp;&nbsp;</tt> (<tt>0</tt>)<tt> &nbsp;</tt> = OK, <code><var>callback</var></code> has been called at
        least once.<br>
        <tt>PLUGIN_NO_OP</tt> (<tt>300</tt>) = Cancel. Do not add/play anything.<br>
        <tt>PLUGIN_ERROR</tt> (<tt>500</tt>) = Internal error.</li>
    </ul>
  </body>
</html>
